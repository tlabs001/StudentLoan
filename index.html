<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Loan Tower — v0.9 (pickups, feather, guard archetypes)</title>
<style>
  html, body { margin:0; background:#0b0b0b; height:100%; overscroll-behavior:none; }
  canvas { display:block; margin:0 auto; background:#0e0e10; outline:none; }
  .hudBox {
    position:fixed; right:12px; top:12px; width:380px;
    background:rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.18);
    border-radius:10px; padding:10px; color:#fff; font:13px/1.25 monospace;
    text-shadow:0 1px 2px #000;
    user-select:none;
  }
  .row { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; gap:6px; flex-wrap:wrap; }
  .meter { position:relative; height:12px; background:#1c1f25; border:1px solid rgba(255,255,255,0.12); border-radius:6px; overflow:hidden; }
  .fill { position:absolute; left:0; top:0; bottom:0; width:0%; background:linear-gradient(90deg,#73ffa6,#39d17e); }
  .fill.red { background:linear-gradient(90deg,#ff7373,#d13939); }
  .small { font-size:12px; opacity:0.9; }
  .note { margin-top:8px; min-height:18px; opacity:0.95; }
  .center { position:fixed; left:0; right:0; top:40%; text-align:center; color:#fff; font:20px monospace; text-shadow:0 2px 6px #000; display:none; }
  .btn { padding:2px 6px; border:1px solid rgba(255,255,255,0.25); border-radius:6px; background:rgba(255,255,255,0.08); cursor:pointer; }
  .btn.active { background:rgba(120,255,160,0.25); border-color:rgba(120,255,160,0.6); }
  .btnGroup { display:flex; gap:6px; flex-wrap:wrap; }
  .pill { padding:1px 6px; border-radius:999px; background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.2); }
</style>
</head>
<body>
<canvas id="game" width="1180" height="660" tabindex="0"></canvas>

<div class="hudBox">
  <div class="row">
    <div class="btnGroup" id="modeGroup">
      <span class="small">Mode:</span>
      <button class="btn active" data-mode="test" id="btnTest">Test</button>
      <button class="btn" data-mode="normal" id="btnNormal">Normal</button>
    </div>
    <div class="btnGroup" id="weaponGroup">
      <span class="small">Weapon:</span>
      <button class="btn active" data-weapon="pistol" id="btnPistol">Pistol (1)</button>
      <button class="btn" data-weapon="flame" id="btnFlame">Flame (2)</button>
      <button class="btn" data-weapon="melee" id="btnMelee">Melee (3)</button>
    </div>
  </div>
  <div class="row"><div id="floor">Floor 1 / 36</div><div id="time">7:00 PM ➜ 12:00 AM</div></div>
  <div class="row"><div>Checking</div><div id="checkVal">$100</div></div>
  <div class="meter"><div id="checkFill" class="fill" style="width:40%"></div></div>
  <div class="row" style="margin-top:6px;"><div>Savings</div><div id="saveVal">$1200</div></div>
  <div class="meter"><div id="saveFill" class="fill red" style="width:100%"></div></div>
  <div class="row small" style="margin-top:8px;">
    <div id="servers">Servers: 0/0</div>
    <div id="alarms">Alarms: OK</div>
  </div>
  <div class="row small">
    <div id="ammo">Ammo</div>
    <div id="inv">Inv: —</div>
  </div>
  <div class="row small">
    <span class="pill" id="filesPill">Files: 0</span>
    <span class="pill" id="intelPill">Intel: 0</span>
    <span class="pill" id="featherPill">Feather: —</span>
  </div>
  <div class="note small" id="note">Good evening. Destroy the servers before midnight.</div>
</div>

<div class="center" id="msg"></div>

<script>

// --- Game time scale ---
var TIME_SCALE = 2; // 2× faster: 2 in-game hours per real hour
(()=>{
// ===== Audio =====
let ac;
function getAC(){ if(!ac){ ac=new (window.AudioContext||window.webkitAudioContext)(); } return ac; }
function beep({freq=660,dur=0.12,type='sine',gain=0.08}={}){
  try{
    const ctx=getAC(); const o=ctx.createOscillator(); const g=ctx.createGain();
    o.type=type; o.frequency.value=freq;
    g.gain.value=gain; o.connect(g); g.connect(ctx.destination);
    const t=ctx.currentTime;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(gain, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.start(t); o.stop(t+dur+0.05);
  }catch(e){}
}
function motor({startFreq=120,endFreq=70,dur=0.6,gain=0.09}={}){
  try{
    const ctx=getAC(); const o=ctx.createOscillator(); const g=ctx.createGain();
    o.type='sawtooth'; o.frequency.value=startFreq;
    g.gain.value=gain; o.connect(g); g.connect(ctx.destination);
    const t=ctx.currentTime;
    o.frequency.setValueAtTime(startFreq, t);
    o.frequency.exponentialRampToValueAtTime(endFreq, t+dur);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(gain, t+0.05);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.start(t); o.stop(t+dur+0.1);
  }catch(e){}
}
function chime(){ beep({freq:740,dur:0.08}); setTimeout(()=>beep({freq:1100,dur:0.1}),70); }
function lockedBuzz(){ motor({startFreq:160,endFreq:80,dur:0.2,gain:0.06}); }
function doorOpenSFX(){ motor({startFreq:220,endFreq:90,dur:0.8,gain:0.08}); }
function boom(){ motor({startFreq:80,endFreq:40,dur:0.4,gain:0.12}); }

// ===== Input fixes =====
const block = new Set([' ', 'ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','PageUp','PageDown']);
window.addEventListener('keydown',(e)=>{ if(block.has(e.key) || block.has(e.code)) e.preventDefault(); },{passive:false});
const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d'); canvas.focus();
window.addEventListener('click', ()=>{ canvas.focus(); getAC(); });

// ===== Canvas & Timing =====
const W=1180, H=660;
let last=performance.now();

// ===== Game State =====
const FLOORS=36;
const GRAV=0.7, FRICTION=0.86, RUN=4.1, JUMP=13, SPRINT=1.35;
const FLASH_DIST = 240;
let currentFloor=1;
let pause=false;
let testMode=true; // default TEST
const initialSpawnX = 120;

// Camera
let camX=0, seenDoor=false;

// Player
const player = {
  x:initialSpawnX, y: 0, w:22, h:46,
  vx:0, vy:0, onGround:false, facing:1, crouch:false, crouchOffset:0,
  sprint:false, climbing:false, inVent:false, hidden:false, spotted:false,
  checking:100, savings:1200,
  hasScrew:false, hasCharges:true,
  hasFeather:false, featherEnergy:0, featherMax:100, featherRecharge:12, lastFlap:0, flapCooldown:120,
  files:0, intel:0,
  weapon:'pistol',
  pistol:{ammo:9, reserve:60, cooldown:140, last:0, muzzleUntil:0},
  flame:{fuel:90, cooldown:60, last:0}, // "ammo" for flamethrower
  melee:{cooldown:240, last:0},
  hurtUntil:0,
  dmgGateUntil:0, // 3s gate in this build
};

// Time: 7PM → 12AM ≈ 12 minutes
const TOTAL_TIME_MS = 12*60*1000;
let startClock = performance.now();
function timeLeftMs(){ return Math.max(0, TOTAL_TIME_MS - (performance.now() - startClock)); }
function fmtClock(ms){
  const frac = 1 - (ms / TOTAL_TIME_MS);
  const minutesFromStart = Math.floor(frac * 5 * 60);
  let hour = 19 + Math.floor(minutesFromStart/60);
  let mins = minutesFromStart % 60;
  if (hour >= 24) hour -= 24;
  const ampm = hour >= 12 ? 'PM' : 'AM';
  let dispH = hour % 12; if (dispH === 0) dispH = 12;
  return `${dispH}:${mins.toString().padStart(2,'0')} ${ampm}`;
}

// Level arrays
let walls=[], floorSlab=null, windowsArr=[], ladders=[], vents=[], servers=[], panels=[], cameras=[], guards=[], desks=[], plants=[], waterCoolers=[], spotlights=[], door=null, pickups=[], movingPlatforms=[];
let destroyedOnFloor=0, totalServersOnFloor=0;
let alarm=false, alarmUntil=0;
let inSub=false; // vent sub-level
let sub = null;
let entryVentWorld = null;

// Projectiles
const bullets=[];

// Smoke overlay
let smokeActive=false, smokeT=0;

// HUD helpers
const noteEl = document.getElementById('note');
const floorEl = document.getElementById('floor');
const timeEl = document.getElementById('time');
const checkVal = document.getElementById('checkVal');
const saveVal = document.getElementById('saveVal');
const checkFill = document.getElementById('checkFill');
const saveFill = document.getElementById('saveFill');
const serversEl = document.getElementById('servers');
const alarmsEl = document.getElementById('alarms');
const ammoEl = document.getElementById('ammo');
const invEl = document.getElementById('inv');
const filesPill = document.getElementById('filesPill');
const intelPill = document.getElementById('intelPill');
const featherPill = document.getElementById('featherPill');

// Buttons
const btnTest=document.getElementById('btnTest');
const btnNormal=document.getElementById('btnNormal');
const btnP=document.getElementById('btnPistol');
const btnF=document.getElementById('btnFlame');
const btnM=document.getElementById('btnMelee');

function setMode(m){
  testMode = (m==='test');
  btnTest.classList.toggle('active', testMode);
  btnNormal.classList.toggle('active', !testMode);
  notify(testMode? "TEST mode: revive on death." : "NORMAL mode: restart on death.");
}
btnTest.onclick=()=>setMode('test');
btnNormal.onclick=()=>setMode('normal');
function setWeapon(w){
  player.weapon=w;
  btnP.classList.toggle('active', w==='pistol');
  btnF.classList.toggle('active', w==='flame');
  btnM.classList.toggle('active', w==='melee');
  beep({freq: w==='pistol'?600:w==='flame'?500:440,dur:0.06});
}
btnP.onclick=()=>setWeapon('pistol');
btnF.onclick=()=>setWeapon('flame');
btnM.onclick=()=>setWeapon('melee');

// Helpers
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const now=()=>performance.now();
function rect(a,b){ return !(a.x+a.w<b.x || a.x>b.x+b.w || a.y+a.h<b.y || a.y>b.y+b.h); }
function rect2(x,y,w,h,b){ return !(x+w<b.x || x>b.x+b.w || y+h<b.y || y>b.y+b.h); }
function centerNote(text,ms=1600){ const m=document.getElementById('msg'); m.textContent=text; m.style.display='block'; setTimeout(()=>m.style.display='none',ms); }
function notify(text){ noteEl.textContent = text; }
function handleDeath(){
  pause=true;
  if(testMode){
    centerNote("Revived (TEST mode).");
    setTimeout(()=>{
      pause=false;
      player.checking=100;
      player.dmgGateUntil=now()+1000;
      player.x=initialSpawnX; player.y=0; player.vx=player.vy=0;
      player.y = floorSlab.y - player.h;
      notify("Revived on same floor.");
    }, 700);
  } else {
    centerNote("You ran out of Checking. Restarting at Floor 1...");
    setTimeout(()=>{
      // hard reset
      currentFloor=1;
      player.checking=100; player.savings=1200;
      player.hasScrew=false; player.hasFeather=false; player.featherEnergy=0;
      player.files=0; player.intel=0;
      player.pistol={ammo:9,reserve:60,cooldown:140,last:0,muzzleUntil:0};
      player.flame.fuel=90; player.melee.last=0;
      startClock = performance.now();
      makeLevel(currentFloor);
      player.x=initialSpawnX; player.y=0; player.vx=player.vy=0;
      player.y=floorSlab.y - player.h;
      pause=false;
      notify("Restarted at Floor 1.");
    }, 1200);
  }
}
function damage(){
  const t=now();
  if(t < player.dmgGateUntil) return; // invulnerable
  player.checking = Math.max(0, player.checking - 10);
  player.hurtUntil = t+120;
  player.dmgGateUntil = t + 3000; // 3s gate
  if(player.checking===0){ handleDeath(); }
}
function addChecking(n){ player.checking = clamp(player.checking+n,0,9999); }
function addAmmo(n){ player.pistol.reserve = clamp(player.pistol.reserve+n, 0, 999); }
function addFuel(n){ player.flame.fuel = clamp(player.flame.fuel+n, 0, 200); }

// Input
const keys={};
window.addEventListener('keydown', e=>{
  const k=e.key.toLowerCase(); keys[k]=true;
  if(k==='r'){ // reload pistol
    if(player.weapon==='pistol'){
      const need = 9 - player.pistol.ammo;
      const take = Math.min(need, player.pistol.reserve);
      if(take>0){ player.pistol.ammo += take; player.pistol.reserve -= take; }
    }
  }
  if(k==='1') setWeapon('pistol');
  if(k==='2') setWeapon('flame');
  if(k==='3') setWeapon('melee');
  if(k===' '){ interact(); }
},{passive:false});
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; }, {passive:false});

// mouse
let mouseDown=false;
window.addEventListener('mousedown', ()=>{ mouseDown=true; attack(); });
window.addEventListener('mouseup', ()=>{ mouseDown=false; });

// ==== Level generation ====
function guardArchetypeForFloor(i){
  const types=['pistol'];
  if(i>=6) types.push('auto');
  if(i>=12) types.push('ninja');
  if(i>=18) types.push('launcher');
  return types[Math.floor(Math.random()*types.length)];
}
function makeGuard(x,y,i){
  const type = guardArchetypeForFloor(i);
  let base = {x, y, w:20, h:42, vx:(x< W? 0.9 : -0.9), hp: type==='ninja'?3:2, dmg:10, t:0, suit:false, lastShot:0, type};
  if(type==='auto'){ base.vx*=1.0; }
  if(type==='ninja'){ base.vx*=1.6; base.shoot=false; }
  if(type==='launcher'){ base.vx*=0.8; }
  return base;
}

function makeLevel(i){
  walls=[]; windowsArr=[]; ladders=[]; vents=[]; servers=[]; panels=[]; cameras=[]; guards=[];
  desks=[]; plants=[]; waterCoolers=[]; spotlights=[]; pickups=[]; movingPlatforms=[];
  door=null; alarm=false; alarmUntil=0; destroyedOnFloor=0; totalServersOnFloor=0;
  inSub=false; sub=null; entryVentWorld=null; smokeActive=false; seenDoor=false;

  const yBase = H-50;
  // Back wall & windows
  walls.push({x:0,y:0,w:3*W,h:H});
  const cols=18, rows=3, spacingX=(3*W-200)/cols, startX=80;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const wx=startX+c*spacingX, wy=60+r*48;
      windowsArr.push({x:wx,y:wy,w:36,h:24});
    }
  }
  // Floor slab
  floorSlab={x:0,y:yBase,w:3*W,h:16};

  // 3–4 platform layers
  const layers = 3 + (Math.random()<0.5?0:1);
  const layerYs = [];
  for(let L=0; L<layers; L++){
    const ly = yBase - 120 - L*100;
    layerYs.push(ly);
    const segW = 0.52*W;
    for(let s=0;s<3;s++){
      const wx = 0.25*W + s*0.95*W;
      walls.push({x:wx, y:ly, w:segW, h:10, isPlatform:true});
      if(Math.random()<0.6){
        movingPlatforms.push({x:wx+segW+40, y:ly-30, w:90, h:10, vx: (Math.random()<0.5?-1:1)*1.0, range:120, cx:0});
      }
    }
  }

  // Props
  const deskCount=7+((i%3)*2);
  for(let d=0; d<deskCount; d++){
    const x=120 + d* ( (3*W-240)/deskCount );
    const w=70,h=38; const y=yBase - h;
    desks.push({x,y,w,h});
  }
  for(let p=0;p<6;p++){
    const x=180 + p*220, y=yBase-30;
    plants.push({x,y,w:24,h:30});
  }
  waterCoolers.push({x: 1.2*W, y: yBase-60, w:28,h:60});

  // Ladders
  ladders.push({x: 0.8*W, y: yBase- (layers*100 + 40), w:20, h:(layers*100 + 40)});
  ladders.push({x: 1.8*W, y: yBase- (layers*100 + 40), w:20, h:(layers*100 + 40)});

  // Vents
  vents.push({x: 0.6*W+40, y: layerYs[0]-24, w:26,h:20, needScrew:true, open:false, id:'A'});
  vents.push({x: 2.1*W, y: yBase-46, w:26,h:20, needScrew:true, open:false, id:'B'});

  // Pickups (more scatter): files, intel, ammo, cash, feather (rare)
  const pickCount = 14;
  for(let k=0;k<pickCount;k++){
    const ptypePool = ['file','intel','ammo','cash','cash','ammo'];
    if(Math.random()<0.12) ptypePool.push('feather');
    const type = ptypePool[Math.floor(Math.random()*ptypePool.length)];
    // choose a layer or floor
    const onPlatform = Math.random()<0.65;
    const y = onPlatform ? (layerYs[Math.floor(Math.random()*layerYs.length)] - 22) : (yBase - 24);
    const x = 120 + Math.random()*(3*W-240);
    pickups.push({type, x, y, w:18, h:18, amount: type==='cash'? (10 + Math.floor(Math.random()*20)) : (type==='ammo'? 18 : undefined)});
  }
  // ensure screwdriver sometimes
  if(i%2===1 && !player.hasScrew){ pickups.push({type:'screw', x: 0.3*W, y: yBase-24, w:18, h:18}); }

  // Servers spread
  const scount = 3 + (Math.random()<0.5?1:0);
  const positions = [];
  for(let s=0;s<2;s++){ positions.push({x: 200 + s*350 + (i%3)*40, y: yBase-36}); }
  for(const ly of layerYs){ if(Math.random()<0.8) positions.push({x: 300 + Math.random()*(3*W-600), y: ly-26}); }
  for(let k=0;k<scount && positions.length>0;k++){
    const idx = Math.floor(Math.random()*positions.length);
    const p = positions.splice(idx,1)[0];
    servers.push({x:p.x, y:p.y, w:28, h:26, hp: 12, destroyed:false, armed:false, armTime:0});
  }
  totalServersOnFloor = servers.length;

  // Alarm panel
  panels.push({x: 2.5*W, y: yBase-60, w:28,h:24, disabled:false});

  // Spotlight strip
  spotlights.push({x:0.4*W, y:yBase-100, w:80,h:18, range:200, t:0, speed:1.0});

  // Elevator door
  door = { x: 3*W-160, y: yBase-120, w:120, h:120, unlocked:false, open:false, lift:0, glowUntil:0 };

  // Initial guards
  const gcount = 7 + Math.min(6, Math.floor(i/3));
  for(let g=0; g<gcount; g++){
    let gx = Math.random()<0.5? 80 : (3*W-200);
    if(Math.abs(gx - player.x) < 2*FLASH_DIST) gx = (gx< W ? 3*W-200 : 80);
    if(Math.abs(gx - initialSpawnX) < 2*FLASH_DIST) gx = (gx< W ? 3*W-200 : 80);
    if(Math.abs(gx - door.x) < 320) gx = (gx< W ? 3*W-200 : 80);
    guards.push(makeGuard(gx, yBase-42, i));
  }

  // Camera start
  camX = clamp(player.x - W*0.45, 0, 3*W - W);
}

// === Vent sub-levels per vent id ===
function makeSubLevel(fromVent){
  inSub=true;
  entryVentWorld = {x:fromVent.x, y:fromVent.y};

  const twoBosses = Math.random() < 0.5;
  sub = {
    id: fromVent.id,
    floor:{x:80,y:H-120,w:W-160,h:12},
    walls:[{x:80,y:80,w:W-160,h:H-200}],
    vents:[{x:100,y:H-160,w:26,h:20, exit:true}],
    loot:[],
    bosses:[],
    guards:[]
  };
  const seedShift = fromVent.id==='A' ? 0 : 120;
  sub.loot.push({type:'cash', x: 200+seedShift, y: H-140, w:16, h:12, amount:40});
  sub.loot.push({type:'ammo', x: 260+seedShift, y: H-140, w:16, h:12, amount:30});
  if(Math.random()<0.3) sub.loot.push({type:'intel', x: 320+seedShift, y:H-140, w:16, h:12});

  sub.bosses.push({x: W-260, y: H-162, w:24, h:46, vx:-0.9, hp:16, suit:true, lastShot:0, type:'auto'});
  if(twoBosses){
    sub.bosses.push({x: W-380, y: H-162, w:24, h:46, vx:0.8, hp:16, suit:true, lastShot:0, type:'launcher'});
  }

  sub.guards.push({x: 420, y:H-162, w:20, h:42, vx:0.7, hp:3, lastShot:0, type:'pistol'});
  sub.guards.push({x: 520, y:H-162, w:20, h:42, vx:-0.6, hp:3, lastShot:0, type:'ninja'});

  player.x = 120; player.y = sub.floor.y - player.h; player.vx=player.vy=0;
  centerNote(`Vent ${fromVent.id}: server vault`, 900);
  notify(twoBosses ? "Two bosses detected in vents." : "Boss detected in vents.");
}

// Interact
function inViewport(x){ return x>=camX && x<=camX+W; }
function nearDoor(){
  return !inSub && Math.abs((player.x+player.w/2) - (door.x+door.w/2)) < 70 && Math.abs((player.y+player.h) - (door.y+door.h)) < 140;
}
function interact(){
  if(pause) return;
  const p={x:player.x, y:player.y, w:player.w, h:player.h};

  if(!inSub){
    // Pickups
    for(const it of pickups){
      if(it.type && rect(p,it)){
        if(it.type==='screw'){ player.hasScrew=true; it.type=null; centerNote("Picked up screwdriver."); chime(); notify("Screwdriver acquired."); }
        if(it.type==='ammo'){ addAmmo(it.amount||18); it.type=null; centerNote("Ammo +"+(it.amount||18)); beep({freq:520}); notify("Ammo restocked."); }
        if(it.type==='cash'){ addChecking(it.amount||15); it.type=null; centerNote("Checking +$"+(it.amount||15)); beep({freq:600}); notify("Found cash."); }
        if(it.type==='file'){ player.files++; it.type=null; centerNote("Collected file."); beep({freq:700}); notify("File collected."); }
        if(it.type==='intel'){ player.intel++; it.type=null; centerNote("Collected intel."); beep({freq:820}); notify("Intel collected."); }
        if(it.type==='feather'){ player.hasFeather=true; player.featherEnergy=player.featherMax; it.type=null; centerNote("Feather acquired — air flaps!"); chime(); notify("Feather lets you flap midair."); }
      }
    }
    // Vents → sub-level
    for(const v of vents){
      if(rect(p,{x:v.x-10,y:v.y-10,w:v.w+20,h:v.h+20})){
        if(v.needScrew && !player.hasScrew){ centerNote("Vent screwed shut. Need screwdriver."); lockedBuzz(); notify("Vent locked—find screwdriver."); }
        else { v.open=true; makeSubLevel(v); chime(); }
      }
    }
    // Servers: plant explosive
    for(const s of servers){
      if(!s.destroyed && rect(p,{x:s.x-14,y:s.y-8,w:s.w+28,h:s.h+16})){
        if(!s.armed){ s.armed=true; s.armTime=now()+900; centerNote("Charge planted!"); beep({freq:880}); notify("Explosives armed."); }
      }
    }
    // Alarm panel
    for(const a of panels){
      if(!a.disabled && rect(p,{x:a.x-18,y:a.y-18,w:a.w+36,h:a.h+36})){
        a.disabled=true; alarm=false; alarmUntil=0; centerNote("Alarm disabled."); chime(); notify("Alarms disabled.");
      }
    }
    // Door → next level
    if(nearDoor()){
      if(!door.unlocked){ centerNote("Door locked."); lockedBuzz(); notify("Door locked."); }
      else {
        if(!door.open){
          door.open=true;
          doorOpenSFX();
          setTimeout(()=>{
            currentFloor = Math.min(FLOORS, currentFloor+1);
            centerNote(`Floor ${currentFloor}`);
            notify(`Entered floor ${currentFloor}.`);
            player.x=initialSpawnX; player.y=0; player.vx=player.vy=0;
            makeLevel(currentFloor);
            player.y = floorSlab.y - player.h;
          }, 700);
        }
      }
    }
  } else {
    // Sub-level exit vent (same vent back)
    for(const v of sub.vents){
      if(v.exit && rect(p,{x:v.x-10,y:v.y-10,w:v.w+20,h:v.h+20})){
        inSub=false; 
        player.vx=player.vy=0;
        const targetX = (entryVentWorld? entryVentWorld.x : 0.6*W+40);
        const targetY = (entryVentWorld? entryVentWorld.y : floorSlab.y-160);
        player.x = targetX; player.y = targetY - player.h;
        camX = clamp(player.x - W*0.45, 0, 3*W - W);
        sub=null; entryVentWorld=null;
        centerNote("Exited vents", 700); chime(); notify("Returned from vents.");
      }
    }
    // loot
    for(const it of (sub?sub.loot:[])){
      if(it.type && rect(p,it)){
        if(it.type==='cash'){ addChecking(it.amount||20); it.type=null; centerNote("Found checking +"+(it.amount||20)); beep({freq:600}); notify("Cash found."); }
        if(it.type==='ammo'){ addAmmo(it.amount||18); it.type=null; centerNote("Found ammo +"+(it.amount||18)); beep({freq:520}); notify("Ammo found."); }
        if(it.type==='intel'){ player.intel++; it.type=null; centerNote("Intel +1"); beep({freq:820}); notify("Intel collected."); }
      }
    }
  }
}

// Attacks / weapons
function attack(){
  if(pause) return;
  const t=now();
  if(player.weapon==='pistol'){
    if(t - player.pistol.last < player.pistol.cooldown) return;
    if(player.pistol.ammo<=0){ centerNote("Reload (R)"); beep({freq:320}); notify("Out of ammo."); return; }
    player.pistol.last=t;
    player.pistol.ammo--;
    const dir = player.facing>0 ? 1 : -1;
    const bx = player.x + (dir>0?player.w:0);
    const by = player.y + 16;
    bullets.push({type:'bullet', x:bx, y:by, vx: dir*12, vy:0, life:1000, from:'player'});
    player.pistol.muzzleUntil = t + 80;
    if(!player.hidden && !player.inVent){ alarm=true; alarmUntil=now()+4000; }
  } else if(player.weapon==='flame'){
    if(player.flame.fuel<=0) { notify("Out of fuel."); return; }
    if(t - player.flame.last < player.flame.cooldown) return;
    player.flame.last=t; player.flame.fuel = Math.max(0, player.flame.fuel-1);
    const dir = player.facing>0 ? 1 : -1;
    const bx = player.x + (dir>0?player.w:0);
    const by = player.y + 18;
    for(let i=0;i<3;i++){
      bullets.push({type:'flame', x:bx, y:by+(Math.random()*10-5), vx: dir*(6+Math.random()*2), vy:(Math.random()*2-1), life:220, from:'player'});
    }
    if(!player.hidden && !player.inVent){ alarm=true; alarmUntil=now()+3000; }
  } else if(player.weapon==='melee'){
    if(t - player.melee.last < player.melee.cooldown) return;
    player.melee.last=t;
    const range=36;
    const px = player.x + (player.facing>0 ? player.w : -range);
    const hitBox={x:px, y:player.y, w:range, h:player.h};
    let hits=0;
    const list = inSub? (sub? [...sub.guards, ...sub.bosses] : []) : guards;
    for(const g of list){
      if(rect(hitBox,g)){ g.hp -= 2; hits++; }
    }
    if(hits>0) beep({freq:520}); else beep({freq:380});
  }
}

// continuous fire for flame while held
function tickContinuous(){
  if(mouseDown && player.weapon==='flame'){ attack(); }
  setTimeout(tickContinuous, 80);
}
tickContinuous();

// Guards fire by type
function guardFire(g){
  const t=now();
  if(g.type==='pistol'){
    if(t - g.lastShot < 700) return;
    g.lastShot = t;
    const dir = (player.x > g.x ? 1 : -1);
    bullets.push({type:'enemy', x:g.x + (dir>0?g.w:0), y:g.y+18, vx: dir*9, vy:0, life:900, from:'guard'});
  } else if(g.type==='auto'){
    if(t - g.lastShot < 120) return;
    g.lastShot = t;
    const dir = (player.x > g.x ? 1 : -1);
    bullets.push({type:'enemy', x:g.x + (dir>0?g.w:0), y:g.y+14+Math.random()*8, vx: dir*(9+Math.random()*2), vy:(Math.random()*1-0.5), life:700, from:'guard'});
  } else if(g.type==='launcher'){
    if(t - g.lastShot < 1400) return;
    g.lastShot = t;
    const dir = (player.x > g.x ? 1 : -1);
    bullets.push({type:'rocket', x:g.x + (dir>0?g.w:0), y:g.y+16, vx: dir*5, vy:0, life:1200, from:'guard', blast: true});
  } else if(g.type==='ninja'){
    // no ranged; close collision handled elsewhere
  }
}

// ========= Update =========
function update(dt){
  // Track "seen door"
  if(!seenDoor && (inViewport(door.x) || Math.abs(player.x - door.x) < W*0.4)){ seenDoor=true; }

  if(timeLeftMs()<=0){
    pause=true; player.savings=0; centerNote("Midnight hit — Savings auto-debited.", 2200); notify("Savings drained at midnight.");
  }

  // Inputs
  const jumpPressed = (keys['w']||keys['arrowup']);
  player.crouch = keys['s'] || keys['arrowdown'] || keys['x'];
  player.sprint = keys['shift'];
  let ax=0;
  if(keys['a']||keys['arrowleft']) { ax-=1; player.facing=-1; }
  if(keys['d']||keys['arrowright']) { ax+=1; player.facing= 1; }
  const maxRun = RUN*(player.sprint?SPRINT:1)*(player.crouch?0.6:1);

  // Crouch offset
  const targetOffset = player.crouch? 8 : 0;
  player.crouchOffset += (targetOffset - player.crouchOffset)*0.25;

  // Feather energy recharge
  if(player.hasFeather){
    player.featherEnergy = clamp(player.featherEnergy + player.featherRecharge*dt*60*(player.onGround?1.6:0.8), 0, player.featherMax);
  }

  // Ladder climbing
  let onLadder=false;
  if(!inSub){ onLadder = ladders.some(l=>rect(player,l)); }
  const tryingClimb = (keys['w']||keys['arrowup']||keys['s']||keys['arrowdown']);
  player.climbing = onLadder && tryingClimb;
  if(player.climbing){
    player.vy = (keys['w']||keys['arrowup'])? -3 : (keys['s']||keys['arrowdown'])? 3 : 0;
  } else {
    // Ground jump
    if(jumpPressed && player.onGround){ player.vy = -JUMP; player.onGround=false; }
    // Air flap if feather
    if(jumpPressed && !player.onGround && player.hasFeather && (now()-player.lastFlap>player.flapCooldown) && player.featherEnergy>0){
      player.vy = Math.min(player.vy, -9);
      player.lastFlap = now();
      player.featherEnergy = Math.max(0, player.featherEnergy - 12);
      beep({freq:900,dur:0.05});
    }
  }

  // Movement
  player.vx += ax*0.8;
  player.vx *= player.onGround?FRICTION:0.99;
  player.vx = clamp(player.vx, -maxRun, maxRun);
  if(!player.climbing) player.vy += GRAV*(player.hasFeather?0.92:1);

  // Apply
  player.x += player.vx; player.y += player.vy;
  player.onGround=false;

  if(!inSub){
    // Bounds
    player.x = clamp(player.x, 0, 3*W - player.w);

    // Floor & platforms
    if(rect(player, floorSlab)){
      if(player.vy>0 && player.y+player.h - floorSlab.y < 28){
        player.y = floorSlab.y - player.h; player.vy=0; player.onGround=true;
      }
    }
    for(const w of walls){
      if(!w.isPlatform) continue;
      if(rect(player,w) && player.vy>0 && player.y+player.h - w.y < 24){
        player.y = w.y - player.h; player.vy=0; player.onGround=true;
      }
    }
    for(const m of movingPlatforms){
      m.cx = (m.cx||0) + m.vx;
      if(Math.abs(m.cx)>m.range){ m.vx*=-1; }
      m.x += m.vx;
      if(rect(player, {x:m.x,y:m.y,w:m.w,h:m.h}) && player.vy>0 && player.y+player.h - m.y < 20){
        player.y = m.y - player.h; player.vy=0; player.onGround=true;
        player.x += m.vx;
      }
    }

    // Hidden under desk when crouched
    player.hidden=false;
    for(const d of desks){
      const zone={x:d.x, y:d.y, w:d.w, h:d.h};
      if(player.crouch && rect(player, zone)){ player.hidden=true; break; }
    }

    // Spotlights add alarm if touched
    const detectable = !(player.hidden || player.inVent);
    for(const s of spotlights){
      s.t += dt*s.speed;
      const sx = s.x + Math.sin(s.t)*s.range;
      const bar={x:sx-120, y:s.y, w:240, h:s.h};
      if(detectable && rect(player, bar)){ alarm=true; alarmUntil=now()+6000; }
    }
    if(now()>alarmUntil) alarm=false;

    // Guards
    const yGround = floorSlab.y;
    const blockReinforce = (destroyedOnFloor===totalServersOnFloor) && seenDoor;
    if(alarm && guards.length<16 && !blockReinforce){
      if(Math.random()<0.05){
        let spawnX = Math.random()<0.5? 40 : (3*W-60);
        if(Math.abs(spawnX - player.x) < 2*FLASH_DIST) spawnX = (spawnX< W ? 3*W-60 : 40);
        if(Math.abs(spawnX - initialSpawnX) < 2*FLASH_DIST) spawnX = (spawnX< W ? 3*W-60 : 40);
        if(Math.abs(spawnX - door.x) < 320) spawnX = (spawnX< W ? 3*W-60 : 40);
        guards.push(makeGuard(spawnX, yGround-42, currentFloor));
      }
    }
    for(const g of guards){
      g.t += dt*TIME_SCALE;
      g.x += g.vx;
      if(g.x<40){ g.x=40; g.vx=Math.abs(g.vx); }
      if(g.x>3*W-60){ g.x=3*W-60; g.vx=-Math.abs(g.vx); }

      // Flashlight-only detection
      const coneDir = (g.vx>=0?1:-1);
      const gx = coneDir>0 ? g.x+g.w : g.x;
      const px = player.x+player.w/2, py=player.y+player.h/2;
      const dx = px-gx, dy=py-(g.y+10);
      const inCone = detectable && (coneDir*dx>0) && Math.abs(dy)<50 && Math.abs(dx)<FLASH_DIST;

      if(inCone){
        alarm=true; alarmUntil=now()+7000;
        if(Math.abs(dx)<40 && Math.abs(dy)<20){ damage(); }
        else {
          if(g.type!=='ninja') guardFire(g);
        }
      }
      // ninja rushes even without cone when close
      if(g.type==='ninja' && Math.abs(px - (g.x+g.w/2))<90 && Math.abs(py - (g.y+g.h/2))<40){
        if(rect(player,g)) damage();
      }
      if(rect(player,g)) damage(); // collision baseline
    }
    // kills + reward
    for(let i=guards.length-1;i>=0;i--){
      if(guards[i].hp<=0){ guards.splice(i,1); addChecking(10); notify("+$10 (guard)"); }
    }

    // Servers armed -> destroyed
    for(const s of servers){
      if(!s.destroyed && s.armed && now()>s.armTime){
        s.destroyed=true; addChecking(10); notify("+$10 (server bonus)");
      }
    }
    destroyedOnFloor = servers.filter(x=>x.destroyed).length;
    if(destroyedOnFloor===totalServersOnFloor && !door.unlocked){
      door.unlocked=true; door.glowUntil = now()+2000; chime(); notify("All servers down. Elevator unlocked.");
      smokeActive=true;
    }

    // Door anim & camera
    if(door.open){ door.lift = Math.min(1, door.lift + 0.06); }
    else { door.lift = Math.max(0, door.lift - 0.04); }
    camX = clamp(player.x - W*0.45, 0, 3*W - W);

  } else {
    // Sublevel physics
    player.x = clamp(player.x, 80, W-80 - player.w);
    if(rect(player, sub.floor)){
      if(player.vy>0 && player.y+player.h - sub.floor.y < 28){
        player.y = sub.floor.y - player.h; player.vy=0; player.onGround=true;
      }
    }
    const mobs = [...sub.guards, ...sub.bosses];
    for(const m of mobs){
      m.x += (m.vx||0);
      if(m.x<120 || m.x>W-200) m.vx*=-1;
      if(Math.random()<0.02){ guardFire(m); }
      if(rect(player,m)) damage();
    }
    // removals
    for(let i=sub.guards.length-1;i>=0;i--){
      if(sub.guards[i].hp<=0){ sub.guards.splice(i,1); addChecking(10); notify("+$10 (vent guard)"); }
    }
    for(let i=sub.bosses.length-1;i>=0;i--){
      if(sub.bosses[i].hp<=0){ sub.bosses.splice(i,1); addChecking(10); notify("+$10 (boss)"); }
    }
  }

  // Projectiles
  for(const b of bullets){
    if(b.type==='flame'){
      b.x += b.vx; b.y += b.vy; b.life -= 30;
    } else if(b.type==='rocket'){
      b.x += b.vx; b.y += b.vy; b.life -= 12;
      // explode on player or time out
      const pbox={x:player.x,y:player.y,w:player.w,h:player.h};
      if(rect2(b.x-3,b.y-3,6,6,pbox) || b.life<=0){
        // blast
        const blast = {x:b.x-30,y:b.y-20,w:60,h:40};
        if(rect2(player.x, player.y, player.w, player.h, blast)) damage();
        boom();
        b.life=0;
      }
    } else {
      b.x += b.vx; b.y += b.vy; b.life -= 16;
    }
    if(!inSub){
      if(b.x<0 || b.x>3*W || b.life<=0) b.life=0;
      if(b.from==='player'){
        for(const g of guards){
          const box={x:g.x,y:g.y,w:g.w,h:g.h};
          if(rect2(b.x-3,b.y-3,6,6,box)){ g.hp -= (b.type==='flame'? 2 : 1); b.life=0; break; }
        }
        for(const s of servers){
          const box={x:s.x,y:s.y,w:s.w,h:s.h};
          if(rect2(b.x-3,b.y-3,6,6,box)){ s.hp-= (b.type==='flame'? 3 : 2); if(s.hp<=0){ s.destroyed=true; } b.life=0; break; }
        }
      } else {
        const pbox={x:player.x,y:player.y,w:player.w,h:player.h};
        if(b.type!=='rocket' && rect2(b.x-2,b.y-2,4,4,pbox)){ damage(); b.life=0; }
      }
    } else {
      if(b.x<80 || b.x>W-80 || b.life<=0) b.life=0;
      if(b.from==='player'){
        for(const g of sub.guards){
          const box={x:g.x,y:g.y,w:g.w,h:g.h};
          if(rect2(b.x-3,b.y-3,6,6,box)){ g.hp -= (b.type==='flame'? 2 : 1); b.life=0; }
        }
        for(const boss of sub.bosses){
          const box={x:boss.x,y:boss.y,w:boss.w,h:boss.h};
          if(rect2(b.x-3,b.y-3,6,6,box)){ boss.hp -= (b.type==='flame'? 2 : 1); b.life=0; }
        }
      } else {
        const pbox={x:player.x,y:player.y,w:player.w,h:player.h};
        if(b.type!=='rocket' && rect2(b.x-2,b.y-2,4,4,pbox)){ damage(); b.life=0; }
      }
    }
  }
  for(let i=bullets.length-1;i>=0;i--) if(bullets[i].life<=0) bullets.splice(i,1);

  // HUD update
  floorEl.textContent=`Floor ${currentFloor} / ${FLOORS}`;
  timeEl.textContent= `${fmtClock(timeLeftMs())} ➜ 12:00 AM`;
  serversEl.textContent=`Servers: ${destroyedOnFloor}/${totalServersOnFloor}`;
  alarmsEl.textContent= alarm? 'Alarms: ACTIVE' : 'Alarms: OK';
  let ammoText = '';
  if(player.weapon==='pistol') ammoText = `Pistol: ${player.pistol.ammo}/${player.pistol.reserve}`;
  else if(player.weapon==='flame') ammoText = `Flame fuel: ${player.flame.fuel}`;
  else ammoText = `Melee: ready${now()-player.melee.last<player.melee.cooldown?' (cooling)':''}`;
  ammoEl.textContent = ammoText;
  const inv=[]; if(player.hasScrew) inv.push('Screwdriver'); if(player.hasCharges) inv.push('Charges');
  if(player.hasFeather) inv.push('Feather');
  invEl.textContent=`Inv: ${inv.join(', ')||'—'}`;
  checkVal.textContent = `$${player.checking}`;
  saveVal.textContent = `$${player.savings}`;
  checkFill.style.width = `${Math.min(100, player.checking/200*100)}%`;
  saveFill.style.width = `${Math.min(100, player.savings/2000*100)}%`;
  filesPill.textContent = `Files: ${player.files}`;
  intelPill.textContent = `Intel: ${player.intel}`;
  featherPill.textContent = player.hasFeather ? `Feather: ${Math.round(player.featherEnergy)}` : "Feather: —";
}

// ========= Draw =========
function draw(){
  ctx.fillStyle='#0e0f13'; ctx.fillRect(0,0,W,H);

  if(!inSub){
    const ox = -camX;

    // back wall
    for(const wall of walls){
      ctx.fillStyle = wall.isPlatform? '#2b2e36' : '#14161b';
      ctx.fillRect(wall.x+ox, wall.y, wall.w, wall.h);
    }
    // windows
    for(const wdw of windowsArr){
      ctx.fillStyle='rgba(120,160,220,0.22)';
      ctx.fillRect(wdw.x+ox,wdw.y,wdw.w,wdw.h);
      ctx.fillStyle='rgba(200,220,255,0.07)';
      ctx.fillRect(wdw.x+3+ox,wdw.y+3,wdw.w-6,wdw.h-6);
    }
    // floor
    ctx.fillStyle='#2b2e36'; ctx.fillRect(floorSlab.x+ox,floorSlab.y,floorSlab.w,floorSlab.h);

    // desks
    for(const d of desks){
      ctx.fillStyle='#5a4634'; ctx.fillRect(d.x+ox,d.y,d.w,d.h);
      ctx.fillStyle='#3e2f23'; ctx.fillRect(d.x+6+ox,d.y+d.h-10,d.w-12,8);
      ctx.fillStyle='#3a2a1f'; ctx.fillRect(d.x+4+ox,d.y+d.h,6,10); ctx.fillRect(d.x+d.w-10+ox,d.y+d.h,6,10);
    }
    // plants
    for(const p of plants){
      ctx.fillStyle='#2f7a3a'; ctx.fillRect(p.x+4+ox,p.y,16,22);
      ctx.fillStyle='#6b4e31'; ctx.fillRect(p.x+ox,p.y+22,24,8);
    }
    // water cooler
    for(const wc of waterCoolers){
      ctx.fillStyle='#9ec7ff'; ctx.fillRect(wc.x+ox,wc.y, wc.w, wc.h);
      ctx.fillStyle='#cfe3ff'; ctx.fillRect(wc.x+4+ox,wc.y+6, wc.w-8, wc.h-12);
    }

    // ladders
    for(const l of ladders){
      ctx.fillStyle='#6c6c6c'; ctx.fillRect(l.x+ox,l.y,l.w,l.h);
      ctx.strokeStyle='rgba(255,255,255,0.2)';
      for(let yy=0; yy<l.h; yy+=10){ ctx.beginPath(); ctx.moveTo(l.x+2+ox, l.y+yy); ctx.lineTo(l.x+l.w-2+ox, l.y+yy); ctx.stroke(); }
    }

    // moving platforms
    for(const m of movingPlatforms){
      ctx.fillStyle='#444';
      ctx.fillRect(m.x+ox,m.y,m.w,m.h);
      ctx.fillStyle='#777'; ctx.fillRect(m.x+4+ox,m.y+2,m.w-8,2);
    }

    // vents
    for(const v of vents){
      ctx.fillStyle=v.open? '#6c6c6c' : '#4b4b4b';
      ctx.fillRect(v.x+ox,v.y,v.w,v.h);
      ctx.strokeStyle='rgba(255,255,255,0.15)';
      for(let i=2;i<v.w-2;i+=4){ ctx.beginPath(); ctx.moveTo(v.x+i+ox,v.y+2); ctx.lineTo(v.x+i+ox,v.y+v.h-2); ctx.stroke(); }
    }

    // servers
    for(const s of servers){
      ctx.fillStyle = s.destroyed? '#333' : '#3e6cff';
      ctx.fillRect(s.x+ox,s.y,s.w,s.h);
      if(!s.destroyed){
        ctx.fillStyle = s.armed? '#ffd54d' : (Math.random()<0.5?'#ff4545':'#45ff59');
        ctx.fillRect(s.x+s.w-6+ox,s.y+4,4,4);
      }
    }

    // alarm panel
    for(const a of panels){
      ctx.fillStyle = a.disabled ? '#2b4b2b' : '#6b2222';
      ctx.fillRect(a.x+ox,a.y,a.w,a.h);
    }

    // guards with flashlight cone
    for(const g of guards){
      ctx.fillStyle='rgba(255,255,160,0.10)';
      const coneDir = (g.vx>=0?1:-1);
      ctx.beginPath();
      ctx.moveTo(g.x + (coneDir>0?g.w:0)+ox, g.y+10);
      ctx.lineTo(g.x + (coneDir>0?g.w+FLASH_DIST:-FLASH_DIST)+ox, g.y-10 + Math.sin(g.t)*20);
      ctx.lineTo(g.x + (coneDir>0?g.w+FLASH_DIST:-FLASH_DIST)+ox, g.y+30 + Math.cos(g.t)*20);
      ctx.closePath(); ctx.fill();
      // body
      // tint by type
      let tint = '#2f6fa2';
      if(g.type==='auto') tint='#3c8a3c';
      if(g.type==='launcher') tint='#8a3c3c';
      if(g.type==='ninja') tint='#2f2f2f';
      ctx.fillStyle=tint; ctx.fillRect(g.x+2+ox,g.y+10,g.w-4,22);
      ctx.fillStyle='#1d1d1d'; ctx.fillRect(g.x+3+ox,g.y+32,6,10); ctx.fillRect(g.x+g.w-9+ox,g.y+32,6,10);
      ctx.fillStyle='#1d3b56'; ctx.fillRect(g.x+4+ox,g.y, g.w-8, 10);
    }

    // Elevator Door
    ctx.fillStyle='#2a2a2a'; ctx.fillRect(door.x+ox, door.y, door.w, door.h);
    const panelH = door.h-20;
    const liftPx = door.lift * (panelH);
    ctx.fillStyle='#4a2a2a'; ctx.fillRect(door.x+8+ox, door.y+door.h-panelH - liftPx, door.w-16, panelH);
    if(now()<door.glowUntil){
      ctx.fillStyle='rgba(120,255,160,0.22)';
      ctx.fillRect(door.x-6+ox, door.y-6, door.w+12, door.h+12);
    }
    if(nearDoor() && door.unlocked && !door.open){
      ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='14px monospace';
      ctx.fillText('Press SPACE to Enter', door.x+16+ox, door.y-8);
    }

    // bullets & flames & rockets
    for(const b of bullets){
      if(b.type==='flame'){
        ctx.fillStyle='rgba(255,180,80,0.9)';
        ctx.fillRect(b.x-3+ox,b.y-3,6,6);
      } else if(b.type==='rocket'){
        ctx.fillStyle='rgba(255,120,120,0.9)';
        ctx.fillRect(b.x-3+ox,b.y-2,8,4);
      } else {
        ctx.fillStyle = b.from==='player' ? '#9cf' : '#f88';
        ctx.fillRect(b.x-2+ox,b.y-2,4,4);
      }
    }

    // pickups visuals
    for(const it of pickups){
      if(!it.type) continue;
      const x=it.x+ox, y=it.y;
      if(it.type==='screw'){ ctx.fillStyle='#d9d9d9'; ctx.fillRect(x,y,it.w,it.h); }
      if(it.type==='ammo'){ ctx.fillStyle='#ffd24a'; ctx.fillRect(x,y,it.w,it.h); }
      if(it.type==='cash'){ ctx.fillStyle='#6fff6f'; ctx.fillRect(x,y,it.w,it.h); }
      if(it.type==='file'){ ctx.fillStyle='#9ec7ff'; ctx.fillRect(x,y,it.w,it.h); }
      if(it.type==='intel'){ ctx.fillStyle='#c89eff'; ctx.fillRect(x,y,it.w,it.h); }
      if(it.type==='feather'){ ctx.fillStyle='#fff7a8'; ctx.fillRect(x,y,it.w,it.h); }
    }

    // player
    const px=player.x+ox, py=player.y + player.crouchOffset;
    if(now()<player.hurtUntil){ ctx.fillStyle='rgba(255,120,120,0.8)'; ctx.fillRect(px-2,py-2,player.w+4,player.h+4); }
    ctx.fillStyle='#f0D2b6'; ctx.fillRect(px+6, py+2, 10, 10);
    ctx.fillStyle='#d14d4d'; ctx.fillRect(px+4, py+12, player.w-8, player.crouch?18:22);
    ctx.fillStyle='#3a3a3a'; if(!player.crouch){ ctx.fillRect(px+4, py+34, 6, 12); ctx.fillRect(px+player.w-10, py+34, 6, 12); } else { ctx.fillRect(px+5, py+30, 12, 8); }
    if(now() < player.pistol.muzzleUntil && player.weapon==='pistol'){
      ctx.fillStyle='rgba(255,220,120,0.9)';
      const mx = px + (player.facing>0 ? player.w+2 : -8);
      ctx.fillRect(mx, py+16, 8, 4);
    }
    if(player.weapon==='flame' && mouseDown){
      ctx.fillStyle='rgba(255,160,60,0.15)';
      const dir = player.facing>0?1:-1;
      ctx.beginPath();
      ctx.moveTo(px + (dir>0?player.w:0), py+18);
      ctx.lineTo(px + (dir>0?player.w+90:-90), py+4);
      ctx.lineTo(px + (dir>0?player.w+90:-90), py+32);
      ctx.closePath(); ctx.fill();
    }

    // Smoke overlay when servers down
    if(smokeActive){
      smokeT += 0.01;
      for(let i=0;i<6;i++){
        const a = 0.06 + 0.02*Math.sin(smokeT + i);
        ctx.fillStyle = `rgba(200,200,220,${a})`;
        const sx = (i*260 + (Math.sin(smokeT*0.7+i)*120)) + ox;
        ctx.fillRect(sx, floorSlab.y-140 + Math.sin(smokeT+i)*8, 240, 120);
      }
    }

  } else {
    // Sub-level draw
    for(const w of sub.walls){
      ctx.fillStyle='#171920'; ctx.fillRect(w.x,w.y,w.w,w.h);
    }
    ctx.fillStyle='#343844'; ctx.fillRect(sub.floor.x, sub.floor.y, sub.floor.w, sub.floor.h);
    for(const v of sub.vents){
      ctx.fillStyle='#6c6c6c'; ctx.fillRect(v.x,v.y,v.w,v.h);
      ctx.strokeStyle='rgba(255,255,255,0.15)';
      for(let i=2;i<v.w-2;i+=4){ ctx.beginPath(); ctx.moveTo(v.x+i,v.y+2); ctx.lineTo(v.x+i,v.y+v.h-2); ctx.stroke(); }
    }
    for(const it of sub.loot){
      if(!it.type) continue;
      if(it.type==='cash'){ ctx.fillStyle='#6fff6f'; ctx.fillRect(it.x,it.y,it.w,it.h); }
      if(it.type==='ammo'){ ctx.fillStyle='#ffd24a'; ctx.fillRect(it.x,it.y,it.w,it.h); }
      if(it.type==='intel'){ ctx.fillStyle='#c89eff'; ctx.fillRect(it.x,it.y,it.w,it.h); }
    }
    for(const g of sub.guards){
      let tint = '#2f6fa2'; if(g.type==='ninja') tint='#2f2f2f';
      ctx.fillStyle=tint; ctx.fillRect(g.x+2,g.y+10,g.w-4,22);
      ctx.fillStyle='#1d1d1d'; ctx.fillRect(g.x+3,g.y+32,6,10); ctx.fillRect(g.x+g.w-9,g.y+32,6,10);
      ctx.fillStyle='#1d3b56'; ctx.fillRect(g.x+4,g.y, g.w-8, 10);
    }
    for(const b of sub.bosses){
      let tint = '#3c8a3c';
      if(b.type==='launcher') tint='#8a3c3c';
      ctx.fillStyle=tint; ctx.fillRect(b.x+2,b.y+10,b.w-4,22);
      ctx.fillStyle='#1d1d1d'; ctx.fillRect(b.x+3,b.y+32,6,10); ctx.fillRect(b.x+b.w-9,b.y+32,6,10);
      ctx.fillStyle='#3a3a3a'; ctx.fillRect(b.x+4,b.y, b.w-8, 10);
    }
    for(const b of bullets){
      if(b.type==='flame'){
        ctx.fillStyle='rgba(255,180,80,0.9)';
        ctx.fillRect(b.x-3,b.y-3,6,6);
      } else if(b.type==='rocket'){
        ctx.fillStyle='rgba(255,120,120,0.9)';
        ctx.fillRect(b.x-3,b.y-2,8,4);
      } else {
        ctx.fillStyle = b.from==='player' ? '#9cf' : '#f88';
        ctx.fillRect(b.x-2,b.y-2,4,4);
      }
    }
    const px=player.x, py=player.y + player.crouchOffset;
    if(now()<player.hurtUntil){ ctx.fillStyle='rgba(255,120,120,0.8)'; ctx.fillRect(px-2,py-2,player.w+4,player.h+4); }
    ctx.fillStyle='#f0d2b6'; ctx.fillRect(px+6, py+2, 10, 10);
    ctx.fillStyle='#d14d4d'; ctx.fillRect(px+4, py+12, player.w-8, player.crouch?18:22);
    ctx.fillStyle='#3a3a3a'; if(!player.crouch){ ctx.fillRect(px+4, py+34, 6, 12); ctx.fillRect(px+player.w-10, py+34, 6, 12); } else { ctx.fillRect(px+5, py+30, 12, 8); }
  }
}

// ===== Loop =====
function loop(ts){
  const dt=Math.min(1/30,(ts-last)/1000); last=ts;
  if(!pause){
    update(dt);
    draw();
  }
  requestAnimationFrame(loop);
}

// Init
function init(){
  setMode('test');
  setWeapon('pistol');
  notify("Evening infiltration. New intel & loot on each floor.");
  makeLevel(currentFloor);
  player.y = floorSlab.y - player.h;
  requestAnimationFrame(loop);
}
init();
})();

</script>
</body>
</html>
